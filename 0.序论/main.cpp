#include <stdio.h>
#include <iostream>
#include <arpa/inet.h>
using namespace std;

//定义一个共用体类型：多个成员共享一个成员的空间，共享的是所占内存空间最大的那个成员
union Info
{
    int  num;   // 四字节整数
    char ch;    // 一字节
};


int main(int argc, const char *argv[]) {

    /*  字节序的概念
    字节序：计算机在存储多字节整数时，根据主机的CPU处理架构不同，我们将主机分成大端存储的
    主机和小端存储的主机
        大端存储：内存地址低位存储的是数据的高位
        小端存储：内存地址的低位存储的是数据的低位*/
    
    /* 使用指针来进行判断 */

    // 定义一个整形变量
    int num = 0x12345678;

    // 定义一个字符类型的指针，指向整形变量的起始地址
    char *ptr = (char *)&num;

    //对ptr所指向的字节中的内容进行判断，如果是0x12则说明是大端存储
    //如果是0x78则说明是小端存储
    if (*ptr == 0x12)
    {
        cout << "big endian" << endl;
    }
    else if (*ptr == 0x78)
    {
        cout << "little endian" << endl;
    }
    
    /* 使用共用体判断主机的大小端 */
    
    //定义一个共用体变量
    union Info temp;
    //给其整形成员赋值
    temp.num = 0x12345678;
    //判断其ch成员
    if (temp.ch == 0x12)
    {
        cout << "big endian" << endl;
    }
    else if (temp.ch == 0x78)
    {
        cout << "little endian" << endl;
    }
    
    /* 关于网络字节序和主机字节序之间相互转换的函数
        主机: host
        网络: network
        转换: to

        #include <arpa/inet.h>
        uint32_t htonl(uint32_t hostlong);
        功能:将4字节整数主机字节序转换为网络字节序，参数
        是主机字节序，返回值是网络字节序

        uint32_t ntohl(uint32_t hostshort);
        功能:将2字节整数主机字节序转换为网络字节序，参数
        是主机字节序，返回值是网络字节序

        uint16_t ntohl(uint32_t netlong);
        功能:将4字节整数的网络字节序转换为主机字节序，参数
        是网络字节序，返回值是主机字节序

        uint16_t ntohs(uint32_t netshort);
        功能:将2字节整数的网络字节序转换为主机字节序，参数
        是网络字节序，返回值是主机字节序
    */
    
    // 定义一个4字节整数
    num = 0x12345678;
    
    // 调用函数，将该数据转换为网络字节序
    int res = htonl(num); 

    // res = 0x78563412
    printf("res = %#x\n", res);

    /* 注意:
        1.在进行多字节整数网络传输时，需要使用字节序转换函数
        2.在进行单字节整数传输时，不需要使用
        3.在网络中传输字符串时，也不需要使用
    */


    /* ip地址
        ip地址是主机在网络中的唯一标识，由两部分组成，分别是网络号和主机号。
            网络号：确定计算机所从属的网络
            主机号：标识该设备在该网络中的一个编号
        作用：在网络传输过程中，给网络传输载体必须添加的信息，指定源ip地址和目的ip地址，以便于
        找到目的主机*/

    /* 点分十进制
        为了方便记忆，我们将ip地址的每一个字节单独计算出十进制数据，并用点进行分割，这种方式，称
        为点分十进制，在程序中使用的是字符串来存储的。但是，ip地址的本质是4字节无符号整数，在网络
        中进行传输时，需要使用的是4字节无符号整数，而不是点分十进制的字符串。此时，就需要引入关于
        点分十进制数据向4字节无符号整数转换的相关函数
            地址: address
            网络: network
            转换: to
    
    #include <sys/socket.h>
    #include <netinet/in.h>
    #include <arpa/inet.h>
    
    in_addr_t inet_addr(const char *cp);
    功能: 将点分十进制的ip地址转换为4字节无符号整数
    的网络字节序，参数时点分十进制数据，返回值时4字节无符号整数
    
    char *inet_ntoa(struct in_addr in);
    功能: 将4字节无符号整数的网络字节序，转换为点分十
    进制的字符串
    */

    // 地址指针记录ip地址
    const char *ip = "172.20.10.8";

    unsigned int ip_net = inet_addr(ip);

    // AC  14  A  8
    printf("ip_net = %#x\n", ip_net);

    /* 端口号(port)
        作用: 为了区分同一个主机之间的每个进程的，使用端口号来进行标识
        概念: 端口是是一个 2 字节的无符号整数表示的数字，取值范围 [0,65535]
        
        为什么不使用进程号标识，而使用端口号
            答：因为进程号是进程的唯一标识，当同一个应用程序，关闭再打开后，并不是同一个进程号了，
            但是是同一个应用程序
            
            所以，端口号标识的是我们的应用程序，当一个应用程序关闭再打开后，端口号不变
            
        引入端口号后，网络通信的两个重要因素就集结完毕：ip 地址 + 端口号
            ip地址可以在网络中，唯一确定对端的主机地址，通过端口号能够找到该主机中指定的对端应用程序
            
        端口号的分类:
            1.0~1023 ：众所周知的 “VIP”端口号：被特殊的应用程序已经占用了的。
            可以查看 / etc /services 中的文件内容，该文件中记录了特殊的端口号
            TCP和UDP分别使用不同的一套标准
            注意：有时使用这些特殊的端口号时，需要使用管理员权限
            
            2.1024 ~ 49151：用户可分配的端口号
            
            3.49152~65535：动态分配或系统自动分配的端口号
    */
    
    return 0;
}